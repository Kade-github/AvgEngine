/*
    Copyright 2021-2023 AvgEngine - Kade

    Use of this source code without explict permission from owner is strictly prohibited.
*/

#ifndef STRINGTOOLS_H
#define STRINGTOOLS_H

#pragma once
#include <unordered_map>
#include <algorithm>
#include <vector>
#include <sys/stat.h>
#include <chrono>
#include <wtypes.h>
#include <cstdint>
#include <boost/algorithm/string.hpp>
namespace AvgEngine::Utils
{
    class StringTools
    {
    public:


        static bool Contains(std::string& search, std::string find)
        {
            return search.find(find) != std::string::npos;
        }

        static bool Contains(std::wstring& search, std::wstring find)
        {
            return search.find(find) != std::wstring::npos;
        }

        static const wchar_t* GetWC(const char* c)
        {
            const size_t cSize = strlen(c) + 1;
            wchar_t* wc = new wchar_t[cSize];
            mbstowcs(wc, c, cSize);

            return wc;
        }

        static std::string Trim(const std::string& s)
        {
            std::string t = s;
            boost::trim(t);
            return t;
        }

        static std::wstring Trim(const std::wstring& s)
        {
            std::wstring t = s;
            boost::trim(t);
            return t;
        }

        static bool isNumber(const std::string& s)
        {
            if (s.empty()) {
                return false;
            }

            // Check if the string starts with a minus sign
            auto it = s.begin();
            if (*it == '-') {
                ++it;
            }

            // Check if the remaining characters are digits or a decimal point
            return it != s.end() && std::all_of(it, s.end(), [](unsigned char c) {
                return std::isdigit(c) || c == '.';
                });
        }

        static std::wstring S2ws(const std::string& s, bool isUtf8 = true)
        {
            int len;
            int slength = (int)s.length() + 1;
            len = MultiByteToWideChar(isUtf8 ? CP_UTF8 : CP_ACP, 0, s.c_str(), slength, 0, 0);
            std::wstring buf;
            buf.resize(len);
            MultiByteToWideChar(isUtf8 ? CP_UTF8 : CP_ACP, 0, s.c_str(), slength,
                const_cast<wchar_t*>(buf.c_str()), len);
            return buf;
        }

        static std::vector<std::string> Split(std::string s, std::string delimiter) {
            size_t pos_start = 0, pos_end, delim_len = delimiter.length();
            std::string token;
            std::vector<std::string> res;

            while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos) {
                token = s.substr(pos_start, pos_end - pos_start);
                pos_start = pos_end + delim_len;
                res.push_back(token);
            }

            res.push_back(s.substr(pos_start));
            return res;
        }

        static std::vector<std::wstring> Split(std::wstring s, std::wstring delimiter) {
            size_t pos_start = 0, pos_end, delim_len = delimiter.length();
            std::wstring token;
            std::vector<std::wstring> res;

            while ((pos_end = s.find(delimiter, pos_start)) != std::wstring::npos) {
                token = s.substr(pos_start, pos_end - pos_start);
                pos_start = pos_end + delim_len;
                res.push_back(token);
            }

            res.push_back(s.substr(pos_start));
            return res;
        }

        static void ToLower(std::string& s)
        {
            std::transform(s.begin(), s.end(), s.begin(),
                [](unsigned char c) { return std::tolower(c); });
        }

        static void ToUpper(std::string& s)
        {
            std::transform(s.begin(), s.end(), s.begin(),
                [](unsigned char c) { return std::toupper(c); });
        }

        // this is awful (generated by chat gpt btw)

        static int convertKeyNameToKeyCode(const std::string& keyName);

        static std::string convertKeyCodeToKeyName(const int& keyCode);
    };
}

#endif // !STRINGTOOLS_H